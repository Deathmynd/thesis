%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ПРОЕКТИРОВАНИЕ И РЕАЛИЗАЦИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Определение программных компонентов и проектирование архитектуры системы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Проектирование и разработка компонента регистрации новых клиентов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Компонент регистрации новых клиентов предназначен для решения четырех задач:

\begin{enumerate}
	\item Перенаправление всех пользователей заданной подсети на сервер регистрации.
	\item Поддержание работы сервера регистрации.
	\item Регистрация новых клиентов на удаленном сервере.
	\item Предоставление интернета зарегистрированным клиентам.
\end{enumerate}

\subsection{Проектирование архитектуры}

Для того чтобы рассматриваемый компонент был способен реализовывать поставленные задачи, было принято решение, что архитектура приложения будет разделена на три основных модуля. На рис.\ref{fig:CPArchitecture} изображена архитектура всего компонента и системы, с которыми он взаимодействует.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{fig/CPArchitecture}
	\caption{Архитектура компонента регистрации}
	\label{fig:CPArchitecture}
\end{figure}

\textbf{Сервер} необходим для первоначального обслуживания клиентов. Данный модуль слушает 80 и 443 порты и работает по протоколу HTTP и HTTPS соответственно. В его задачи входит:

\begin{itemize}
	\item показ страницы регистрации;
	\item показ пользовательского соглашения;
	\item получение регистрационных данных;
	\item формирование события регистрации клиента;
	\item формирование события, разрешающего клиенту доступ в интернет.
\end{itemize}

\textbf{REST API Клиент} позволяет проверять MAK адрес устройства клиента в базе системы. При наличие адреса, клиенту предоставляется доступ в интернет. Данный модуль также отвечает за регистрацию новых клиентов. Передача данных между модулем и сервером системы осуществляется по протоколу HTTPS, что позволяет защитить информацию от злоумышленников.

\textbf{Межсетевой экран} осуществляет следующие функции:
\begin{itemize}
	\item перенаправляет все запросы новых клиентов на сервер Captive Portal;
	\item блокирует доступ в интернет всем не авторизованным пользователям;
	\item по команде от сервера Captive Portal предоставляет клиентам доступ в интернет.
\end{itemize}

\subsection{Разработка компонента}

Для организации открытой Wi-Fi сети решено использовать утилиту hostapd~\cite{hostapd}. Утилита позволяет создавать Wi-Fi точку доступа с различными парамерами путем конфигурации файла настроек. Используемый в компоненте файл настроек представлен в листинге \ref{listings:hostapd}.

Для корректной работы Wi-Fi сети необходимо наличие DHCP сервера. Роль DHCP сервера в рассматриваемом компоненте выполняет утилита dnsmasq. Для удобства обращение к серверу Captive Portal по установленному локальному имени (localcaptive) используется DNS сервер, который также реализован в утилите dnsmasq. Конфигурационный файл dnsmasq представлен в листинге \ref{listings:dnsmasq}

Предполагается, что разрабатываемый программный компонент будет устанавливаться в устройства со слабой производительностью. К таким устройствам относятся большинство домашних роутеров. Ресурсы таких устройств сильно ограничены. Они могут иметь количество памяти до 20 мб и частоту одноядерного процессора до 500 MHz. В таких условиях использование таких серверов как apache и nginx существенно замедлит работу устройства. В связи с этим, принято решение разрабатывать свой сервер на языке C++.

Для ускорения разработки и уменьшения количества ошибок было решено использовать заготовку для веб-сервера\cite{simpleServer}, написанную на языке С++ и распространяемую по лицензии MIT\cite{simpleServerMIT}. В своей работе данная заготовка использует библиотеку boost.asio\cite{boost}, которая позволяет при необходимости вносить изменения в исходный код как сервера так и библиотеки.

На рис.\ref{fig:CPUML} представлена UML диаграмма компонента регистрации

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{fig/CPUML}
	\caption{UML диаграмма компонента регистрации}
	\label{fig:CPUML}
\end{figure}

Рассмотрим каждый класс и наиболее значимые методы по отдельности.

\textbf{CaptiveBaseServer.}
\textbf{CaptiveServer.}

Функцией этого класса является поддержание работоспособности сервера и выдача команд межсетевому экрану и REST API клиенту.

\textbf{Firewall.}

Объект этого класса выполняет функции сетевого экрана, позволяющие блокировать клиентам доступ в интернет до момента получения команды из класса CaptiveServer.

\textbf{RestClient.}

Данный класс регистрирует на сервере новых клиентов и проверяет наличие MAC адреса в базе данных сервера таргетированной рекламы.

Метод \textit{bool RestClient::isClientExist(std::string mac)} получает в качестве параметра MAC адрес устройства клиента в виде AA:BB:CC:DD:EE:FF. Его задача установить зарегистрирован ли данный MAC в системе. Возвращаемое значение равно true если адрес уже существует. В противном случае возвращается false.

Метод \textit{bool RestClient::registerClient(User user)} получает в качестве параметра объект класса User и совершает попытку его регистрации на сервере. В случае успеха возвращается true, иначе false.

\textbf{User.}

Отвечает за данные, полученные от клиента при регистрации. Поля данного класса отправляются на сервер для регистрации нового клиента.

\textbf{Resources.}

Класс, реализующий паттерн проектирования Singleton. Единственный экземпляр этого класса содержит информацию о всех ресурсах, записанных в конфигурационном файле и необходимых в других компонентах системы.

\textbf{ConfigReader.}

Объект этого класса позволяет считывать конфигурационный файл, сформированный по правилу <<ресурс = значение>>.

\textbf{Logger.}

Еще один класс, реализующий паттерн проектирования Singleton. Позволяет вести логирование работы системы. Логируемые сообщения имеют один из четырех уровней, определенных в перечислении LogLevel: ERROR, WARNING, INFO, DEBUG.

Метод \textit{Logger::get(LogLevel level)} возвращает единственный экземпляр класса Logger и задает уровень логирования.

Для объектов класса переопределен оператор <<<<>>, что позволяет использовать класс следующим образом:

Logger::get(LogLevel::INFO) << System started << std::endl;

Метод \textit{std::string Logger::getTimeForFileName()} позволяет получить время, используемое в имени файла логов.

Метод \textit{std::string Logger::getTimeForFileName()} возвращает время, вставляемое перед каждым сообщением при логировании. Пример файла с логами представлен в листинге \ref{listings:CPlog}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Проектирование и разработка Wi-Fi сканера}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В список задач Wi-Fi сканера входят:

\begin{itemize}
	\item мониторинг радиоканала на частоте 2.4 ГГц;
	\item определение новых устройств в радиусе досягаемости Wi-Fi модуля;
	\item регистрация MAC-адреса устройства на сервере таргетированной рекламы.
\end{itemize}

\subsection{Проектирование архитектуры}

Архитектура Wi-Fi сканера состоит из двух модулей: сканера Wi-Fi сети и модуля регистрации посещений. На рис.\ref{fig:WiFiScanerArch} представлена архитектура Wi-Fi сканера.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{fig/WiFiScanerArch}
	\caption{Архитектура Wi-Fi сканера}
	\label{fig:WiFiScanerArch}
\end{figure}

\textbf{Сканер} осуществляет мониторинг пакетов стандарта 802.11. При выявлении пакетов от нового клиента, MAC-адрес устройства отправителя сохраняется в память для дальнейшей обработки.

\textbf{REST API клиент} регистрирует новые устройства на сервере таргетированной рекламы.

\subsection{Разработка компонента}

Wi-Fi монитор, как и компонент регистрации должен работать на устройстве со слабой производительностью. Из этого следует, что рассматриваемый компонент также следует реализовать на языке C++. Для реализации функциональности монитора решено использовать библиотеку pcap[5]. Библиотека позволяет задавать необходимые настройка интернет адаптеру и просматривать все полученные им пакеты. pcap используют в своей работе такие программы как Wireshark и tcpdump. Для успешного захвата всех пакетов Wi-Fi модулем, необходимо предварительно перевести его в режим монитора. Библиотека pcap позволяет легко сделать это.

На рис.\ref{fig:WiFiScanerUML} представлена UML диаграмма Wi-Fi сканера.

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{fig/WiFiScanerUML}
	\caption{UML диаграмма Wi-Fi сканера}
	\label{fig:WiFiScanerUML}
\end{figure}

Рассмотрим каждый класс в отдельности

\textbf{Scanner}

Экземпляр данного класса устанавливает Wi-Fi модуль в режим монитора, что позволяет обрабатывать в программе все услышанные пакеты.

Метод \textit{int Scanner::start()} запускает режим мониторинга трафика и настраивает фильтрующую функцию на прием пакетов только типа Probe Request.

Метод \textit{void Scanner::sniffCallback(u\_char \*arg, const struct pcap\_pkthdr \*pkthdr, const u\_char \*packet)} позволяет осуществлять обработку каждого отловленного пакета. При нахождении нового устройства, во внутренней памяти создается запись типа Visit с указанием MAC-адреса устройства и временем его появления. Если запись об устройстве уже есть, то обновляется время выхода устройства из зоны действия модуля Wi-Fi.

\textbf{VisitRegistrator}

Класс осуществляет регистрацию на сервере всех устройств, которые были записаны во внутреннюю память объектом класса Scanner.

Метод \textit{void VisitRegistrator::start()} запускает работу созданного объекта. В методе осуществляется постоянная проверка списка объектов Visit с целью выявить устройство, покинувшее зону мониторинга. Это осуществляется путем проверки времени последнего обновления записи. Если запись обновлялась больше 10 минут назад, то такое посещение регистрируется на сервере и удаляется из памяти.

\textbf{Visit}

Класс является контейнером для информации о выявленном устройстве. Его полями являются: MAC-адрес устройства, время его появления, и время выхода из зоны мониторинга.

\textbf{RestClient}

Класс предназначен для регистрации посещений на удаленном сервере с помощью его REST API. 

Метод \textit{bool RestClient::sendVisit(Visit visit)} получает обьет типа Visit и с его помощью формирует POST запрос для отправки на сервер таргетированной рекламы.

Классы \textbf{Resources} и \textbf{ConfigReader} выполняют ту же функцию что и в компоненте регистрации клиентов.

% [1] https://w1.fi/hostapd/
% [2] https://github.com/eidheim/Simple-Web-Server
% [3] https://github.com/eidheim/Simple-Web-Server/blob/master/LICENSE
% [4] https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio.html
% [5] https://www.tcpdump.org/manpages/pcap.3pcap.html